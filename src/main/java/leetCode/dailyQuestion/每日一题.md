# 每日一题

## 九月

### 9.10 找到需要补充粉笔的学生编号

#### 题目

一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。

给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。

请你返回需要 补充 粉笔的学生 编号 。

#### 思路和代码

##### 暴力法

一直重复遍历数组，不断减小K，知道找到比K大的为止.

```java
public int chalkReplacerWithViolence(int[] chalk, int k) {
        int i = 0;
        while(chalk[i] <= k) {
            k -= chalk[i];
            i++;
            if (i == chalk.length) {
                i = 0;
            }
        }
        return i;
    }
```

##### 优化

上面我们其实不用遍历那么多次。我们只需要在遍历的第一次记录**所有学生需要的粉笔总数sum**，再用k对sum取余数。那么我们只需要再遍历一次数组，就能找到那个学生了。

```java
	public int chalkReplacerWithOptimization(int[] chalk, int k) {
        int sum = 0;
        for (int i = 0; i < chalk.length; i++) {
            if(chalk[i] > k) {
                return i;
            }
            k -= chalk[i];
            sum += chalk[i];
        }
        k = k % sum;
        for (int i = 0; i < chalk.length; i++) {
            if(chalk[i] > k) {
                return i;
            }
            k -= chalk[i];
        }
        return -1;
    }
```

时间复杂度：O(n)  需要遍历两次数组

空间复杂度：O(1)



##### 二分查找+前缀和

前面的优化我们还是线性遍历数组。

其实我们可以维护一个前缀和数组，pre[n]表示前n个学生需要的粉笔数。

对K取余后，我们只需要找到pre数组里第一个大于k的数的位置即可。

前缀和的数组是一个递增数组，所以可以用二分搜索查找。

```java
 public int chalkReplacerWithBinarySearch(int[] chalk, int k) {
        int[] pre = new int[chalk.length];
        for (int i = 0;i < chalk.length; i++) {
            if( i == 0) {
                pre[i] = chalk[i];
            } else {
                pre[i] = pre[i - 1] + chalk[i];
            }
            if(chalk[i] > k) {
                return i;
            }
            k -= chalk[i];
        }
        k %= pre[pre.length - 1];
        if(k == 0){
            return 0;
        }
        return BinarySearch(pre, k);
    }

    /**
     * 这里的二分查找是为了找到第一个大于target的数
     */
    private int BinarySearch(int[] arr,int target) {

        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;          //有效防止mid的值溢出
            if (arr[mid] == target) {
                return mid + 1;                           //这里不用担心溢出问题，因为target < arr[arr.length - 1]
            }
            if (arr[mid] < target && arr[mid + 1] >= target) {
                return mid + 1;
            }
            if (arr[mid] > target && (mid == 0 || arr[mid - 1] <= target)) {
                return mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else if(arr[mid] > target) {
                right = mid - 1;
            }
        }
        return -1;
    }
```

时间复杂度：O(n)   遍历一次数组，二分搜索一次前缀和数组。

空间复杂度：O(n)   需要一个n大小的前缀和数组。





### 9.13 回旋镖数量

#### 题目

给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。

返回平面上所有回旋镖的数量。



#### 思路和代码

暴力穷举

满足回旋镖的三个点相当于一个等腰三角形。我们需要把每一个点当成顶点，然后去遍历记录与这个点距离相同的点。我们可以用一个哈希表来存储**距离和满足这个距离的点数**。

```java
/**
     * 暴力枚举，把数组中的每一个点都当作中间的点，然后枚举每一种情况。
     */
    public int numberOfBoomerangs(int[][] points) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int res = 0;
        int size = points.length;
        if (size == 0) {
            return  0;
        }
        for (int i = 0; i < size; i++) {
            map.clear();
            // 这一步是把每个点和选中的点距离算出来，HashMap的键值对是<距离，数量>
            for (int[] point : points) {
                int dis = (point[0] - points[i][0])*(point[0] - points[i][0]) + (point[1] - points[i][1])*(point[1] - points[i][1]);
                // 把是这个距离的数量+1
                map.put(dis, map.getOrDefault(dis, 0) + 1);
            }
            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                int n = entry.getValue();
                // 有n个点和这个点的距离相同， 因为要考虑顺序，所以是n*(n-1)
                res += n * (n - 1);
            }
        }
        return res;
    }
```

**最后遍历哈希表里的值。因为题目要求注意元组顺序，所以如果有n个点和这个点距离相同，那么就有n*(n-1)种情况。**



### 9.14 通过删除字母匹配到字典里最长单词

#### 题目

给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。

如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。

#### 思路及代码

##### 双指针

首先我们可以把问题拆分成两个：

1. 字典里的字符串是不是字符串s的**子序列**？
2. 如何得到长度最长且字典序最小的字符串？

通过问题的描述我们可以知道题目要找的就是子序列。找出子序列的方法我们可以用双指针。

对于字符串**`s`**和可能的子序列**`str`**分别有一个指针。如果指针指向的位置字符相同，那么指针同时+1；如果不同，那么`s`的指针+1。最终如果`str`的指针超出了`str`的长度，说明`str`是`s`子序列。反之则不是。

最后只需要判断一下字典序的问题即可。

```java
    public String findLongestWordWithDoublePoint(String s, List<String> dictionary) {
        String res = "";
        for (String str: dictionary) {
            int i = 0, j = 0;
            while(i < s.length() && j < str.length()) {
                if(s.charAt(i) == str.charAt(j)) {
                    i ++;
                    j ++;
                } else {
                    i++;
                }
            }
            if(j == str.length()) {
                if(str.length() > res.length() || (str.length() == res.length() && str.compareTo(res) < 0)) {
                    res = str;
                }
            }
        }
        return res;
    }
```

时间复杂度： O(d * (m+n))   d是dictionary的长度，m是s的长度，n是dictionary中字符串的平均长度。

空间复杂度： O(1)



##### 排序

对于上述的第二个问题，我们可以先将字典排序，按照长度降序，字典序升序的顺序排序。这样匹配到的第一个字符串就是我们的答案。

```java
    public String findLongestWordWithOrder(String s, List<String> dictionary) {
        dictionary.sort((o1, o2) -> {
            if (o1.length() != o2.length()) {
                return o2.length() - o1.length();
            } else {
                return o1.compareTo(o2);
            }
        });
        for (String str: dictionary) {
            int i = 0, j = 0;
            while(i < s.length() && j < str.length()) {
                if(s.charAt(i) == str.charAt(j)) {
                    i ++;
                    j ++;
                } else {
                    i++;
                }
            }
            if(j == str.length()) {
                return str;
            }
        }
        return "";
    }
```

时间复杂度 : O(d * m * logd + d * (m + n))  

空间复杂度: O(d * m)

对于最坏的情况这种方法是会更慢的， 但是如果运气好就在第一个，那还是能节省不少时间的。



### 9.15 寻找峰值

#### 题目

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 **O(log n)** 的算法来解决此问题。



#### 思路和代码

要找到峰值其实很简单，只需要遍历一次数组，找到满足条件的第一个值即可。但是这样的时间复杂度就为O(n)了，会超时。

既然题目要求用O(log n)的时间复杂度解决这个问题，那么就必须换一个思路。看着这个复杂度第一个蹦出来的就是二分搜索。

但是以往的二分搜索都是在一个有序数组里进行，题目里的数组是无序的，怎么用二分搜索？

二分搜索的核心思想在于缩小搜索范围。而题目里的数组虽然整体无序，但是局部有序。如果把数组里的点画出来连上，那么就会得到一个折线图。

<img src="C:\Users\lukarzhang\AppData\Roaming\Typora\typora-user-images\image-20210915093101073.png" alt="image-20210915093101073" style="zoom:50%;" />

虽然整体是无序的，但是局部是有序的。而我们要找的是峰值，其实可以知道：

- 如果一个数右边是递增的，那么它右边一定有一个峰值。例如图中的A点。
- 如果一个属左边是递减的，那么它左边也一定有一个峰值。力图如中的B点

所以根据这样的性质，我们就可以知道我们要**往哪边缩小查找范围了**。就像滑梯一样。找到中点，判断它左右两边哪边比较低，就往底的那边滑。如果两边都低，那么这个点就是峰值。

```java
	public static int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if(nums[mid] < nums[mid + 1]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l;
    }
```

时间复杂度：O(log n)

空间复杂度：O(1)

