# 每日一题

## 九月

### 9.10 找到需要补充粉笔的学生编号

#### 题目

一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。

给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。

请你返回需要 补充 粉笔的学生 编号 。

#### 思路和代码

##### 暴力法

一直重复遍历数组，不断减小K，知道找到比K大的为止.

```java
public int chalkReplacerWithViolence(int[] chalk, int k) {
        int i = 0;
        while(chalk[i] <= k) {
            k -= chalk[i];
            i++;
            if (i == chalk.length) {
                i = 0;
            }
        }
        return i;
    }
```

##### 优化

上面我们其实不用遍历那么多次。我们只需要在遍历的第一次记录**所有学生需要的粉笔总数sum**，再用k对sum取余数。那么我们只需要再遍历一次数组，就能找到那个学生了。

```java
	public int chalkReplacerWithOptimization(int[] chalk, int k) {
        int sum = 0;
        for (int i = 0; i < chalk.length; i++) {
            if(chalk[i] > k) {
                return i;
            }
            k -= chalk[i];
            sum += chalk[i];
        }
        k = k % sum;
        for (int i = 0; i < chalk.length; i++) {
            if(chalk[i] > k) {
                return i;
            }
            k -= chalk[i];
        }
        return -1;
    }
```

时间复杂度：O(n)  需要遍历两次数组

空间复杂度：O(1)



##### 二分查找+前缀和

前面的优化我们还是线性遍历数组。

其实我们可以维护一个前缀和数组，pre[n]表示前n个学生需要的粉笔数。

对K取余后，我们只需要找到pre数组里第一个大于k的数的位置即可。

前缀和的数组是一个递增数组，所以可以用二分搜索查找。

```java
 public int chalkReplacerWithBinarySearch(int[] chalk, int k) {
        int[] pre = new int[chalk.length];
        for (int i = 0;i < chalk.length; i++) {
            if( i == 0) {
                pre[i] = chalk[i];
            } else {
                pre[i] = pre[i - 1] + chalk[i];
            }
            if(chalk[i] > k) {
                return i;
            }
            k -= chalk[i];
        }
        k %= pre[pre.length - 1];
        if(k == 0){
            return 0;
        }
        return BinarySearch(pre, k);
    }

    /**
     * 这里的二分查找是为了找到第一个大于target的数
     */
    private int BinarySearch(int[] arr,int target) {

        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;          //有效防止mid的值溢出
            if (arr[mid] == target) {
                return mid + 1;                           //这里不用担心溢出问题，因为target < arr[arr.length - 1]
            }
            if (arr[mid] < target && arr[mid + 1] >= target) {
                return mid + 1;
            }
            if (arr[mid] > target && (mid == 0 || arr[mid - 1] <= target)) {
                return mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else if(arr[mid] > target) {
                right = mid - 1;
            }
        }
        return -1;
    }
```

时间复杂度：O(n)   遍历一次数组，二分搜索一次前缀和数组。

空间复杂度：O(n)   需要一个n大小的前缀和数组。





### 9.13 回旋镖数量

#### 题目

给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。

返回平面上所有回旋镖的数量。



#### 思路和代码

暴力穷举

满足回旋镖的三个点相当于一个等腰三角形。我们需要把每一个点当成顶点，然后去遍历记录与这个点距离相同的点。我们可以用一个哈希表来存储**距离和满足这个距离的点数**。

```java
/**
     * 暴力枚举，把数组中的每一个点都当作中间的点，然后枚举每一种情况。
     */
    public int numberOfBoomerangs(int[][] points) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int res = 0;
        int size = points.length;
        if (size == 0) {
            return  0;
        }
        for (int i = 0; i < size; i++) {
            map.clear();
            // 这一步是把每个点和选中的点距离算出来，HashMap的键值对是<距离，数量>
            for (int[] point : points) {
                int dis = (point[0] - points[i][0])*(point[0] - points[i][0]) + (point[1] - points[i][1])*(point[1] - points[i][1]);
                // 把是这个距离的数量+1
                map.put(dis, map.getOrDefault(dis, 0) + 1);
            }
            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
                int n = entry.getValue();
                // 有n个点和这个点的距离相同， 因为要考虑顺序，所以是n*(n-1)
                res += n * (n - 1);
            }
        }
        return res;
    }
```

**最后遍历哈希表里的值。因为题目要求注意元组顺序，所以如果有n个点和这个点距离相同，那么就有n*(n-1)种情况。**



### 9.14 通过删除字母匹配到字典里最长单词

#### 题目

给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。

如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。

#### 思路及代码

##### 双指针

首先我们可以把问题拆分成两个：

1. 字典里的字符串是不是字符串s的**子序列**？
2. 如何得到长度最长且字典序最小的字符串？

通过问题的描述我们可以知道题目要找的就是子序列。找出子序列的方法我们可以用双指针。

对于字符串**`s`**和可能的子序列**`str`**分别有一个指针。如果指针指向的位置字符相同，那么指针同时+1；如果不同，那么`s`的指针+1。最终如果`str`的指针超出了`str`的长度，说明`str`是`s`子序列。反之则不是。

最后只需要判断一下字典序的问题即可。

```java
    public String findLongestWordWithDoublePoint(String s, List<String> dictionary) {
        String res = "";
        for (String str: dictionary) {
            int i = 0, j = 0;
            while(i < s.length() && j < str.length()) {
                if(s.charAt(i) == str.charAt(j)) {
                    i ++;
                    j ++;
                } else {
                    i++;
                }
            }
            if(j == str.length()) {
                if(str.length() > res.length() || (str.length() == res.length() && str.compareTo(res) < 0)) {
                    res = str;
                }
            }
        }
        return res;
    }
```

时间复杂度： O(d * (m+n))   d是dictionary的长度，m是s的长度，n是dictionary中字符串的平均长度。

空间复杂度： O(1)



##### 排序

对于上述的第二个问题，我们可以先将字典排序，按照长度降序，字典序升序的顺序排序。这样匹配到的第一个字符串就是我们的答案。

```java
    public String findLongestWordWithOrder(String s, List<String> dictionary) {
        dictionary.sort((o1, o2) -> {
            if (o1.length() != o2.length()) {
                return o2.length() - o1.length();
            } else {
                return o1.compareTo(o2);
            }
        });
        for (String str: dictionary) {
            int i = 0, j = 0;
            while(i < s.length() && j < str.length()) {
                if(s.charAt(i) == str.charAt(j)) {
                    i ++;
                    j ++;
                } else {
                    i++;
                }
            }
            if(j == str.length()) {
                return str;
            }
        }
        return "";
    }
```

时间复杂度 : O(d * m * logd + d * (m + n))  

空间复杂度: O(d * m)

对于最坏的情况这种方法是会更慢的， 但是如果运气好就在第一个，那还是能节省不少时间的。



### 9.15 寻找峰值

#### 题目

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 **O(log n)** 的算法来解决此问题。



#### 思路和代码

要找到峰值其实很简单，只需要遍历一次数组，找到满足条件的第一个值即可。但是这样的时间复杂度就为O(n)了，会超时。

既然题目要求用O(log n)的时间复杂度解决这个问题，那么就必须换一个思路。看着这个复杂度第一个蹦出来的就是二分搜索。

但是以往的二分搜索都是在一个有序数组里进行，题目里的数组是无序的，怎么用二分搜索？

二分搜索的核心思想在于缩小搜索范围。而题目里的数组虽然整体无序，但是局部有序。如果把数组里的点画出来连上，那么就会得到一个折线图。

<img src="C:\Users\lukarzhang\AppData\Roaming\Typora\typora-user-images\image-20210915093101073.png" alt="image-20210915093101073" style="zoom:50%;" />

虽然整体是无序的，但是局部是有序的。而我们要找的是峰值，其实可以知道：

- 如果一个数右边是递增的，那么它右边一定有一个峰值。例如图中的A点。
- 如果一个属左边是递减的，那么它左边也一定有一个峰值。力图如中的B点

所以根据这样的性质，我们就可以知道我们要**往哪边缩小查找范围了**。就像滑梯一样。找到中点，判断它左右两边哪边比较低，就往底的那边滑。如果两边都低，那么这个点就是峰值。

```java
	public static int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if(nums[mid] < nums[mid + 1]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l;
    }
```

时间复杂度：O(log n)

空间复杂度：O(1)





### 9.16 查找单词II

#### 题目

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。



#### 思路及代码

解决本题要用到字典树。关于什么是字典树这里不过多赘述，可以自行了解。

然后就是对字符网格每一个字符进行邻格遍历。遍历的时候有以下三种情况：

1. 邻格的字符不是该字符的子结点，结束遍历。
2. 邻格的字符是该字符的子结点，那就继续对邻格字符继续遍历。
3. 邻格的字符是该字符的叶子结点，说明匹配上了，把结果添加到结果集中。

最后返回结果集即可。

不过一个网格中可能存在多个相同的目标单词，为了节省时间，我们只需要在匹配到一个单词之后，把这个单词从字典树中删除即可，就不会重复遍历了。

```java
public class WordSearchII {

    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    /**
     * 这题需要用到一个数据结构：字典树。
     * 字典树是一种搜索效率极高的树， 如果搜索的单词长度为S，那么搜索的时间复杂度为O(s)
     * 这题我们先把所有word加入到字典树中，然后对字符网格中每一个字符进行遍历。
     * 因为题目要求同一单元格内的字母不能重复使用，所以在遍历的时候需要先设置为一个非字母的字符即可。
     */
    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();
        for(String word: words) {
            trie.insert(word);
        }

        Set<String> res = new HashSet<>();
        for (int i = 0 ; i < board.length; i++) {
            for(int j = 0; j < board[0].length ; j++) {
                dfs(board, i, j, trie, res);
            }
        }
        return new ArrayList<>(res);
    }

    public void dfs(char[][] board, int i, int j, Trie trie, Set<String> res) {
        // 不是子结点
        if (!trie.children.containsKey(board[i][j])) {
            return;
        }

        char c = board[i][j];
        System.out.println(c);
        Trie t = trie.children.get(c);
        // 是叶子结点
        if (!t.word.equals("")) {
            res.add(t.word);
            t.word = "";
        }

        // 是非叶子结点
        if (!t.children.isEmpty()) {
            board[i][j] = '#';
            for(int[] dir : dirs) {
                int i1 = i + dir[0];
                int j1 = j + dir[1];
                if (i1 >= 0 && i1 < board.length && j1 >= 0 && j1 < board[0].length) {
                    dfs(board, i1, j1, t, res);
                }
            }
            board[i][j] = c;
        }

        // 删除已遍历的
        if (t.children.isEmpty()) {
            trie.children.remove(c);
        }
    }

    class Trie {
        String word;
        HashMap<Character, Trie> children;

        public Trie() {
            this.word = "";
            this.children = new HashMap<>();
        }

        public void insert(String word) {
            Trie node = this;
            for (int i = 0;i < word.length(); i++) {
                Character c = word.charAt(i);
                if (!node.children.containsKey(c)) {
                    node.children.put(c, new Trie());
                }
                node = node.children.get(c);
            }
            node.word = word;
        }
    }

}

```

时间复杂度:O(n * m * 3^(l - 1))  l为单词长度。 每一个单元格最多需要遍历4 * 3^(l-1) 条路径

空间复杂度：O(k * l)， k为 words长度， l为word平均长度，用于字典树的存储开销。 
